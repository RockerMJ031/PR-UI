// backend/larkIntegration.jsw
// Wix åç«¯ Lark é›†æˆæ¨¡å—
// ç”¨äºå‘é€é€šçŸ¥åˆ° Larkï¼ˆé£ä¹¦ï¼‰

import { fetch } from 'wix-fetch';
import { getSecret } from 'wix-secrets-backend';
import { permissions, webMethod } from 'wix-web-module';
import wixData from 'wix-data';

// ==========================================
// Lark é€šçŸ¥ç›¸å…³å‡½æ•°
// ==========================================

/**
 * ä»ç¯å¢ƒå˜é‡è·å– Lark webhook URL
 * @returns {Promise<string>} Webhook URL
 */
const getLarkWebhookUrl = () => {
    return getSecret('LARK_WEBHOOK_URL')
        .then(url => {
            if (!url) {
                throw new Error('LARK_WEBHOOK_URL ç¯å¢ƒå˜é‡æœªè®¾ç½®');
            }
            return url;
        })
        .catch(error => {
            console.error('è·å– Lark Webhook URL å¤±è´¥:', error);
            // è¿”å›é»˜è®¤å€¼æˆ–æŠ›å‡ºé”™è¯¯
            throw new Error('Lark é…ç½®é”™è¯¯');
        });
};

/**
 * å‘é€é€šçŸ¥åˆ° Lark
 * @param {Object} data - é€šçŸ¥æ•°æ®
 * @returns {Promise<Object>} å‘é€ç»“æœ
 */
export async function sendLarkNotification(data) {
    try {
        console.log('å‡†å¤‡å‘é€ Lark é€šçŸ¥:', data);
        
        // è·å– Webhook URL
        const webhookUrl = await getLarkWebhookUrl();
        
        // æ ¼å¼åŒ–æ¶ˆæ¯
        const message = formatLarkMessage(data);
        
        // å‘é€è¯·æ±‚
        const response = await fetch(webhookUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(message)
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        // è®°å½•å‘é€æ—¥å¿—
        await logLarkActivity({
            type: data.type,
            status: 'success',
            message: message.content.text,
            response: result
        });
        
        console.log('Lark é€šçŸ¥å‘é€æˆåŠŸ:', result);
        return { success: true, result };
        
    } catch (error) {
        console.error('å‘é€ Lark é€šçŸ¥é”™è¯¯:', error);
        
        // è®°å½•é”™è¯¯æ—¥å¿—
        await logLarkActivity({
            type: data.type || 'unknown',
            status: 'error',
            message: error.message,
            error: error.message
        });
        
        return { success: false, error: error.message };
    }
}

/**
 * æ ¼å¼åŒ– Lark æ¶ˆæ¯
 * @param {Object} data - åŸå§‹æ•°æ®
 * @returns {Object} æ ¼å¼åŒ–çš„æ¶ˆæ¯
 */
function formatLarkMessage(data) {
    let messageText = '';
    
    switch (data.type) {
        case 'ap_student_registration':
            messageText = `â­ æ–° AP å­¦ç”Ÿæ³¨å†Œ\n\n` +
                        `ğŸ‘¤ å§“å: ${data.studentName}\n` +
                        `ğŸ“§ é‚®ç®±: ${data.studentEmail}\n` +
                        `ğŸ“± ç”µè¯: ${data.studentPhone}\n` +
                        `ğŸ“„ EHCP æ–‡ä»¶: ${data.hasEHCPFile ? 'âœ… å·²ä¸Šä¼ ' : 'âŒ æœªä¸Šä¼ '}\n` +
                        `ğŸ• æ—¶é—´: ${new Date().toLocaleString('zh-CN')}`;
            break;
            
        case 'student_added':
            messageText = `ğŸ“ æ–°å­¦ç”Ÿæ·»åŠ \n\n` +
                        `ğŸ‘¤ å§“å: ${data.studentName}\n` +
                        `ğŸ“§ é‚®ç®±: ${data.studentEmail}\n` +
                        `ğŸ“± ç”µè¯: ${data.studentPhone || 'æœªæä¾›'}\n` +
                        `ğŸ• æ—¶é—´: ${new Date().toLocaleString('zh-CN')}`;
            break;
            
        case 'file_uploaded':
            messageText = `ğŸ“ æ–‡ä»¶ä¸Šä¼ é€šçŸ¥\n\n` +
                        `ğŸ‘¤ å­¦ç”Ÿ: ${data.studentName}\n` +
                        `ğŸ“„ æ–‡ä»¶: ${data.fileName}\n` +
                        `ğŸ“Š å¤§å°: ${formatFileSize(data.fileSize)}\n` +
                        `ğŸ• æ—¶é—´: ${new Date().toLocaleString('zh-CN')}`;
            break;
            
        case 'file_verified':
            messageText = `âœ… æ–‡ä»¶éªŒè¯å®Œæˆ\n\n` +
                        `ğŸ‘¤ å­¦ç”Ÿ: ${data.studentName}\n` +
                        `ğŸ“„ æ–‡ä»¶: ${data.fileName}\n` +
                        `âœ… çŠ¶æ€: éªŒè¯é€šè¿‡\n` +
                        `ğŸ• æ—¶é—´: ${new Date().toLocaleString('zh-CN')}`;
            break;
            
        case 'system_alert':
            messageText = `âš ï¸ ç³»ç»Ÿè­¦å‘Š\n\n` +
                        `ğŸ“‹ ç±»å‹: ${data.alertType}\n` +
                        `ğŸ“ æ¶ˆæ¯: ${data.message}\n` +
                        `ğŸ• æ—¶é—´: ${new Date().toLocaleString('zh-CN')}`;
            break;
            
        default:
            messageText = `ğŸ“Š ç³»ç»Ÿé€šçŸ¥\n\n${JSON.stringify(data, null, 2)}`;
    }
    
    return {
        msg_type: 'text',
        content: {
            text: messageText
        }
    };
}

/**
 * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
 * @param {number} bytes - å­—èŠ‚æ•°
 * @returns {string} æ ¼å¼åŒ–çš„æ–‡ä»¶å¤§å°
 */
function formatFileSize(bytes) {
    if (!bytes) return '0 B';
    
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * è®°å½• Lark æ´»åŠ¨æ—¥å¿—
 * @param {Object} logData - æ—¥å¿—æ•°æ®
 * @returns {Promise<void>}
 */
async function logLarkActivity(logData) {
    try {
        const logEntry = {
            type: logData.type,
            status: logData.status,
            message: logData.message,
            response: logData.response || null,
            error: logData.error || null,
            timestamp: new Date(),
            source: 'lark_integration'
        };
        
        await wixData.insert('LarkActivityLogs', logEntry);
        console.log('Lark æ´»åŠ¨æ—¥å¿—å·²è®°å½•');
        
    } catch (error) {
        console.error('è®°å½• Lark æ´»åŠ¨æ—¥å¿—é”™è¯¯:', error);
        // ä¸æŠ›å‡ºé”™è¯¯ï¼Œé¿å…å½±å“ä¸»æµç¨‹
    }
}

/**
 * æ‰¹é‡å‘é€ Lark é€šçŸ¥
 * @param {Array} notifications - é€šçŸ¥æ•°ç»„
 * @returns {Promise<Object>} æ‰¹é‡å‘é€ç»“æœ
 */
export async function sendBatchLarkNotifications(notifications) {
    try {
        const results = [];
        
        for (const notification of notifications) {
            const result = await sendLarkNotification(notification);
            results.push(result);
            
            // æ·»åŠ å»¶è¿Ÿé¿å…é¢‘ç‡é™åˆ¶
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        const successCount = results.filter(r => r.success).length;
        const failureCount = results.length - successCount;
        
        return {
            success: true,
            total: results.length,
            successful: successCount,
            failed: failureCount,
            results: results
        };
        
    } catch (error) {
        console.error('æ‰¹é‡å‘é€ Lark é€šçŸ¥é”™è¯¯:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * æµ‹è¯• Lark è¿æ¥
 * @returns {Promise<Object>} æµ‹è¯•ç»“æœ
 */
export async function testLarkConnection() {
    try {
        const testData = {
            type: 'system_alert',
            alertType: 'è¿æ¥æµ‹è¯•',
            message: 'Lark é›†æˆæµ‹è¯•æ¶ˆæ¯'
        };
        
        const result = await sendLarkNotification(testData);
        
        return {
            success: result.success,
            message: result.success ? 'Lark è¿æ¥æµ‹è¯•æˆåŠŸ' : 'Lark è¿æ¥æµ‹è¯•å¤±è´¥',
            details: result
        };
        
    } catch (error) {
        console.error('Lark è¿æ¥æµ‹è¯•é”™è¯¯:', error);
        return {
            success: false,
            message: 'Lark è¿æ¥æµ‹è¯•å¤±è´¥',
            error: error.message
        };
    }
}

// ==========================================
// Web æ–¹æ³•ï¼ˆä¾›å‰ç«¯è°ƒç”¨ï¼‰
// ==========================================

/**
 * Web æ–¹æ³•ï¼šå‘é€ Lark é€šçŸ¥
 */
export const sendNotification = webMethod(
    permissions.Anyone,
    async (data) => {
        return await sendLarkNotification(data);
    }
);

/**
 * Web æ–¹æ³•ï¼šæ‰¹é‡å‘é€é€šçŸ¥
 */
export const sendBatchNotifications = webMethod(
    permissions.Anyone,
    async (notifications) => {
        return await sendBatchLarkNotifications(notifications);
    }
);

/**
 * Web æ–¹æ³•ï¼šæµ‹è¯•è¿æ¥
 */
export const testConnection = webMethod(
    permissions.Anyone,
    async () => {
        return await testLarkConnection();
    }
);

// ==========================================
// å¯¼å‡ºæ‰€æœ‰å‡½æ•°
// ==========================================

export {
    sendLarkNotification,
    sendBatchLarkNotifications,
    testLarkConnection
};