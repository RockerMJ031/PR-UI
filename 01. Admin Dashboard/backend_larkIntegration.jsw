// backend/larkIntegration.jsw
// Wix åç«¯ Lark é›†æˆæ¨¡å—
// ç”¨äºå‘é€é€šçŸ¥åˆ° Larkï¼ˆé£ä¹¦ï¼‰

import { fetch } from 'wix-fetch';
import { getSecret } from 'wix-secrets-backend';
import { permissions, webMethod } from 'wix-web-module';
import wixData from 'wix-data';

// ==========================================
// é…ç½®å’Œå¸¸é‡
// ==========================================

const LARK_CONFIG = {
    timeout: 30000, // 30ç§’è¶…æ—¶
    maxRetries: 3,
    retryDelay: 1000, // 1ç§’é‡è¯•å»¶è¿Ÿ
    batchDelay: 100 // æ‰¹é‡å‘é€é—´éš”
};

// é”™è¯¯ç±»å‹å®šä¹‰
const ERROR_TYPES = {
    NETWORK_ERROR: 'NETWORK_ERROR',
    VALIDATION_ERROR: 'VALIDATION_ERROR',
    CONFIG_ERROR: 'CONFIG_ERROR',
    API_ERROR: 'API_ERROR',
    TIMEOUT_ERROR: 'TIMEOUT_ERROR'
};

// è‡ªå®šä¹‰é”™è¯¯ç±»
class LarkIntegrationError extends Error {
    constructor(message, type, originalError = null) {
        super(message);
        this.name = 'LarkIntegrationError';
        this.type = type;
        this.originalError = originalError;
        this.timestamp = new Date().toISOString();
    }
}

// ==========================================
// Lark é€šçŸ¥ç›¸å…³å‡½æ•°
// ==========================================

/**
 * éªŒè¯é€šçŸ¥æ•°æ®
 */
function validateNotificationData(data) {
    if (!data || typeof data !== 'object') {
        throw new LarkIntegrationError('é€šçŸ¥æ•°æ®æ— æ•ˆ', ERROR_TYPES.VALIDATION_ERROR);
    }
    
    if (!data.type || typeof data.type !== 'string' || data.type.trim() === '') {
        throw new LarkIntegrationError('é€šçŸ¥ç±»å‹æ— æ•ˆæˆ–ç¼ºå¤±', ERROR_TYPES.VALIDATION_ERROR);
    }
    
    // æ ¹æ®ä¸åŒç±»å‹éªŒè¯å¿…è¦å­—æ®µ
    const requiredFields = {
        'ap_student_registration': ['studentName', 'studentEmail'],
        'student_added': ['studentName', 'studentEmail'],
        'file_uploaded': ['studentName', 'fileName', 'fileSize'],
        'file_verified': ['studentName', 'fileName'],
        'system_alert': ['alertType', 'message']
    };
    
    const required = requiredFields[data.type];
    if (required) {
        const missing = required.filter(field => !data[field] || (typeof data[field] === 'string' && data[field].trim() === ''));
        if (missing.length > 0) {
            throw new LarkIntegrationError(
                `é€šçŸ¥æ•°æ®ç¼ºå°‘å¿…è¦å­—æ®µ: ${missing.join(', ')}`,
                ERROR_TYPES.VALIDATION_ERROR
            );
        }
    }
    
    return true;
}

/**
 * å¸¦é‡è¯•æœºåˆ¶çš„ HTTP è¯·æ±‚
 */
async function makeRequestWithRetry(url, options, retries = LARK_CONFIG.maxRetries) {
    for (let attempt = 1; attempt <= retries; attempt++) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), LARK_CONFIG.timeout);
            
            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new LarkIntegrationError(
                    `HTTP ${response.status}: ${response.statusText}`,
                    ERROR_TYPES.API_ERROR
                );
            }
            
            return response;
            
        } catch (error) {
            console.error(`Lark è¯·æ±‚å¤±è´¥ (å°è¯• ${attempt}/${retries}):`, error);
            
            if (attempt === retries) {
                if (error.name === 'AbortError') {
                    throw new LarkIntegrationError('è¯·æ±‚è¶…æ—¶', ERROR_TYPES.TIMEOUT_ERROR, error);
                }
                throw error;
            }
            
            // ç­‰å¾…åé‡è¯•
            await new Promise(resolve => setTimeout(resolve, LARK_CONFIG.retryDelay * attempt));
        }
    }
}

/**
 * ä»ç¯å¢ƒå˜é‡è·å– Lark webhook URL
 * @returns {Promise<string>} Webhook URL
 */
const getLarkWebhookUrl = async () => {
    try {
        const url = await getSecret('LARK_WEBHOOK_URL');
        
        if (!url || typeof url !== 'string' || url.trim() === '') {
            throw new LarkIntegrationError('LARK_WEBHOOK_URL ç¯å¢ƒå˜é‡æœªè®¾ç½®æˆ–ä¸ºç©º', ERROR_TYPES.CONFIG_ERROR);
        }
        
        // éªŒè¯ URL æ ¼å¼
        try {
            new URL(url);
        } catch (urlError) {
            throw new LarkIntegrationError('LARK_WEBHOOK_URL æ ¼å¼æ— æ•ˆ', ERROR_TYPES.CONFIG_ERROR, urlError);
        }
        
        return url.trim();
        
    } catch (error) {
        console.error('è·å– Lark Webhook URL å¤±è´¥:', error);
        if (error instanceof LarkIntegrationError) {
            throw error;
        }
        throw new LarkIntegrationError('Lark é…ç½®é”™è¯¯', ERROR_TYPES.CONFIG_ERROR, error);
    }
};

/**
 * å‘é€é€šçŸ¥åˆ° Lark
 * @param {Object} data - é€šçŸ¥æ•°æ®
 * @returns {Promise<Object>} å‘é€ç»“æœ
 */
export async function sendLarkNotification(data) {
    try {
        console.log('å‡†å¤‡å‘é€ Lark é€šçŸ¥:', data);
        
        // éªŒè¯è¾“å…¥æ•°æ®
        validateNotificationData(data);
        
        // è·å– Webhook URL
        const webhookUrl = await getLarkWebhookUrl();
        
        // æ ¼å¼åŒ–æ¶ˆæ¯
        const message = formatLarkMessage(data);
        
        // å‘é€è¯·æ±‚ï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
        const response = await makeRequestWithRetry(webhookUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(message)
        });
        
        const result = await response.json();
        
        // éªŒè¯å“åº”
        if (result.code && result.code !== 0) {
            throw new LarkIntegrationError(
                `Lark API é”™è¯¯: ${result.msg || 'æœªçŸ¥é”™è¯¯'}`,
                ERROR_TYPES.API_ERROR
            );
        }
        
        // è®°å½•å‘é€æ—¥å¿—
        await logLarkActivity({
            type: data.type,
            status: 'success',
            message: message.content.text,
            response: result,
            timestamp: new Date()
        });
        
        console.log('Lark é€šçŸ¥å‘é€æˆåŠŸ:', result);
        return { success: true, result, timestamp: new Date().toISOString() };
        
    } catch (error) {
        console.error('å‘é€ Lark é€šçŸ¥é”™è¯¯:', error);
        
        // è®°å½•é”™è¯¯æ—¥å¿—
        await logLarkActivity({
            type: data?.type || 'unknown',
            status: 'error',
            message: error.message,
            error: error.message,
            errorType: error.type || 'UNKNOWN_ERROR',
            timestamp: new Date()
        });
        
        return { 
            success: false, 
            error: error.message,
            errorType: error.type || 'UNKNOWN_ERROR',
            timestamp: new Date().toISOString()
        };
    }
}

/**
 * å®‰å…¨åœ°è·å–å­—æ®µå€¼
 */
function safeGetField(data, field, defaultValue = 'æœªæä¾›') {
    const value = data[field];
    if (value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) {
        return defaultValue;
    }
    return String(value).trim();
}

/**
 * æ ¼å¼åŒ– Lark æ¶ˆæ¯
 * @param {Object} data - åŸå§‹æ•°æ®
 * @returns {Object} æ ¼å¼åŒ–çš„æ¶ˆæ¯
 */
function formatLarkMessage(data) {
    try {
        let messageText = '';
        const timestamp = new Date().toLocaleString('zh-CN', {
            timeZone: 'Asia/Shanghai',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
        
        switch (data.type) {
            case 'ap_student_registration':
                messageText = `â­ æ–° AP å­¦ç”Ÿæ³¨å†Œ\n\n` +
                            `ğŸ‘¤ å§“å: ${safeGetField(data, 'studentName')}\n` +
                            `ğŸ“§ é‚®ç®±: ${safeGetField(data, 'studentEmail')}\n` +
                            `ğŸ“± ç”µè¯: ${safeGetField(data, 'studentPhone')}\n` +
                            `ğŸ“„ EHCP æ–‡ä»¶: ${data.hasEHCPFile ? 'âœ… å·²ä¸Šä¼ ' : 'âŒ æœªä¸Šä¼ '}\n`;
                
                // æ·»åŠ é™„åŠ ä¿¡æ¯å­—æ®µ
                if (data.additionalInfo) {
                    messageText += `ğŸ“ é™„åŠ ä¿¡æ¯: ${safeGetField(data, 'additionalInfo')}\n`;
                }
                
                messageText += `ğŸ• æ—¶é—´: ${timestamp}`;
                break;
                
            case 'student_added':
                messageText = `ğŸ“ æ–°å­¦ç”Ÿæ·»åŠ \n\n` +
                            `ğŸ‘¤ å§“å: ${safeGetField(data, 'studentName')}\n` +
                            `ğŸ“§ é‚®ç®±: ${safeGetField(data, 'studentEmail')}\n` +
                            `ğŸ“± ç”µè¯: ${safeGetField(data, 'studentPhone')}\n` +
                            `ğŸ• æ—¶é—´: ${timestamp}`;
                break;
                
            case 'file_uploaded':
                messageText = `ğŸ“ æ–‡ä»¶ä¸Šä¼ é€šçŸ¥\n\n` +
                            `ğŸ‘¤ å­¦ç”Ÿ: ${safeGetField(data, 'studentName')}\n` +
                            `ğŸ“„ æ–‡ä»¶: ${safeGetField(data, 'fileName')}\n` +
                            `ğŸ“Š å¤§å°: ${formatFileSize(data.fileSize)}\n` +
                            `ğŸ• æ—¶é—´: ${timestamp}`;
                break;
                
            case 'file_verified':
                messageText = `âœ… æ–‡ä»¶éªŒè¯å®Œæˆ\n\n` +
                            `ğŸ‘¤ å­¦ç”Ÿ: ${safeGetField(data, 'studentName')}\n` +
                            `ğŸ“„ æ–‡ä»¶: ${safeGetField(data, 'fileName')}\n` +
                            `âœ… çŠ¶æ€: ${data.verificationStatus || 'éªŒè¯é€šè¿‡'}\n` +
                            `ğŸ• æ—¶é—´: ${timestamp}`;
                break;
                
            case 'system_alert':
                const alertLevel = data.alertLevel || 'info';
                const alertIcon = {
                    'error': 'ğŸš¨',
                    'warning': 'âš ï¸',
                    'info': 'â„¹ï¸',
                    'success': 'âœ…'
                }[alertLevel] || 'ğŸ“Š';
                
                messageText = `${alertIcon} ç³»ç»Ÿ${alertLevel === 'error' ? 'é”™è¯¯' : alertLevel === 'warning' ? 'è­¦å‘Š' : 'é€šçŸ¥'}\n\n` +
                            `ğŸ“‹ ç±»å‹: ${safeGetField(data, 'alertType')}\n` +
                            `ğŸ“ æ¶ˆæ¯: ${safeGetField(data, 'message')}\n` +
                            `ğŸ• æ—¶é—´: ${timestamp}`;
                break;
                
            default:
                messageText = `ğŸ“Š ç³»ç»Ÿé€šçŸ¥\n\n` +
                            `ğŸ“‹ ç±»å‹: ${data.type}\n` +
                            `ğŸ“ æ•°æ®: ${JSON.stringify(data, null, 2)}\n` +
                            `ğŸ• æ—¶é—´: ${timestamp}`;
        }
        
        // é™åˆ¶æ¶ˆæ¯é•¿åº¦ï¼Œé¿å…è¿‡é•¿
        const MAX_MESSAGE_LENGTH = 4000;
        if (messageText.length > MAX_MESSAGE_LENGTH) {
            messageText = messageText.substring(0, MAX_MESSAGE_LENGTH - 50) + '\n\n... (æ¶ˆæ¯å·²æˆªæ–­)';
        }
        
        return {
            msg_type: 'text',
            content: {
                text: messageText
            }
        };
        
    } catch (error) {
        console.error('æ ¼å¼åŒ– Lark æ¶ˆæ¯é”™è¯¯:', error);
        // è¿”å›åŸºæœ¬çš„é”™è¯¯æ¶ˆæ¯
        return {
            msg_type: 'text',
            content: {
                text: `ğŸ“Š ç³»ç»Ÿé€šçŸ¥\n\næ¶ˆæ¯æ ¼å¼åŒ–å¤±è´¥: ${error.message}\nğŸ• æ—¶é—´: ${new Date().toLocaleString('zh-CN')}`
            }
        };
    }
}

/**
 * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
 * @param {number} bytes - å­—èŠ‚æ•°
 * @returns {string} æ ¼å¼åŒ–çš„æ–‡ä»¶å¤§å°
 */
function formatFileSize(bytes) {
    if (!bytes) return '0 B';
    
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * è®°å½• Lark æ´»åŠ¨æ—¥å¿—
 * @param {Object} logData - æ—¥å¿—æ•°æ®
 * @returns {Promise<void>}
 */
async function logLarkActivity(logData) {
    try {
        const logEntry = {
            type: logData.type,
            status: logData.status,
            message: logData.message,
            response: logData.response || null,
            error: logData.error || null,
            timestamp: new Date(),
            source: 'lark_integration'
        };
        
        await wixData.insert('LarkActivityLogs', logEntry);
        console.log('Lark æ´»åŠ¨æ—¥å¿—å·²è®°å½•');
        
    } catch (error) {
        console.error('è®°å½• Lark æ´»åŠ¨æ—¥å¿—é”™è¯¯:', error);
        // ä¸æŠ›å‡ºé”™è¯¯ï¼Œé¿å…å½±å“ä¸»æµç¨‹
    }
}

/**
 * æ‰¹é‡å‘é€ Lark é€šçŸ¥
 * @param {Array} notifications - é€šçŸ¥æ•°ç»„
 * @returns {Promise<Object>} æ‰¹é‡å‘é€ç»“æœ
 */
export async function sendBatchLarkNotifications(notifications) {
    try {
        const results = [];
        
        for (const notification of notifications) {
            const result = await sendLarkNotification(notification);
            results.push(result);
            
            // æ·»åŠ å»¶è¿Ÿé¿å…é¢‘ç‡é™åˆ¶
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        const successCount = results.filter(r => r.success).length;
        const failureCount = results.length - successCount;
        
        return {
            success: true,
            total: results.length,
            successful: successCount,
            failed: failureCount,
            results: results
        };
        
    } catch (error) {
        console.error('æ‰¹é‡å‘é€ Lark é€šçŸ¥é”™è¯¯:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * æµ‹è¯• Lark è¿æ¥
 * @returns {Promise<Object>} æµ‹è¯•ç»“æœ
 */
export async function testLarkConnection() {
    try {
        const testData = {
            type: 'system_alert',
            alertType: 'è¿æ¥æµ‹è¯•',
            message: 'Lark é›†æˆæµ‹è¯•æ¶ˆæ¯'
        };
        
        const result = await sendLarkNotification(testData);
        
        return {
            success: result.success,
            message: result.success ? 'Lark è¿æ¥æµ‹è¯•æˆåŠŸ' : 'Lark è¿æ¥æµ‹è¯•å¤±è´¥',
            details: result
        };
        
    } catch (error) {
        console.error('Lark è¿æ¥æµ‹è¯•é”™è¯¯:', error);
        return {
            success: false,
            message: 'Lark è¿æ¥æµ‹è¯•å¤±è´¥',
            error: error.message
        };
    }
}

// ==========================================
// Web æ–¹æ³•ï¼ˆä¾›å‰ç«¯è°ƒç”¨ï¼‰
// ==========================================

/**
 * Web æ–¹æ³•ï¼šå‘é€ Lark é€šçŸ¥
 */
export const sendNotification = webMethod(
    permissions.Anyone,
    async (data) => {
        return await sendLarkNotification(data);
    }
);

/**
 * Web æ–¹æ³•ï¼šæ‰¹é‡å‘é€é€šçŸ¥
 */
export const sendBatchNotifications = webMethod(
    permissions.Anyone,
    async (notifications) => {
        return await sendBatchLarkNotifications(notifications);
    }
);

/**
 * Web æ–¹æ³•ï¼šæµ‹è¯•è¿æ¥
 */
export const testConnection = webMethod(
    permissions.Anyone,
    async () => {
        return await testLarkConnection();
    }
);

// ==========================================
// å¯¼å‡ºæ‰€æœ‰å‡½æ•°
// ==========================================

export {
    sendLarkNotification,
    sendBatchLarkNotifications,
    testLarkConnection
};